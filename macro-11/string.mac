;
;  This file contains some routines that work on strings.
;
;	.INCLUDE /MACROS.MAC/
	.TITLE STRING - Collection of routines to work on strings
	.IDENT "X0.00"
;
;  The data structure for a string is defined as follows:
;  str:  byte max - Maximum length of the string.  This should never change
;        byte len - Current length of the string.  Should be <= max
;        bytes buff - Buffer of max bytes containing the string.
;
;  Note that in general, if the destination is not large enough to hold
;  a string transfer, the destination will hold a truncated value.
;
	.PSECT STR,SAV,CON,GBL

	.SBTTL STRLEN - Get the length of a string
;  Called with the address of the string on the stack and returns
;  the length of the string on the stack.
;  Called as:
;  MOV str, -(SP)
;  JSR PC, strlen
;  MOV (SP)+, len
strlen::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV 6(SP), R0	; Get the address of the string
	INC R0		; Point to the length
	MOVB (R0), R1	; Get the length
	BIC #byteh, R1	; Clear any sign bits
	MOV R1, 6(SP)	; Save length on stack
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL STRMAX - Get the maximum length of a string
;  Called with the address of the string on the stack and returns
;  the maximum length of the string on the stack.
;  Called as:
;  MOV str, -(SP)
;  JSR PC, strmax
;  MOV (SP)+, max
strmax::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV 6(SP), R0
	MOVB (R0), R1
	BIC #byteh, R1
	MOV R1, 6(SP)
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL TRIMTS - Trim trailing whitespace from a string
;  Called with the address of the string on the stack and
;  modifes the string to remove any white space at the end
;  of the string.  White space is considered to be any character
;  with a code less than 33 or greater than 126.
;  Called as:
;  MOV str, -(SP)
;  JSR PC, strtrm
;  ADD #2, SP
str = 8.
trimts::
	MOV R0, -(SP)	; Use as addresses
	MOV R1, -(SP)	; Length of string
	MOV R2, -(SP)	; Character to test
;
	MOV str(SP), R0
	INC R0
	MOVB (R0), R1
	BIC #byteh, R1
	INC R0
	ADD R1, R0	; Point to end of string
;
1$:	MOVB -(R0), R2
	CMPB #33., R2
	BHI 2$		; ASCII 32 or less
	CMPB #127., R2
	BHI 3$		; Printable character found
2$:	SOB R1, 1$	; Loop and try again
;
3$:	MOV str(SP), R0
	INC R0
	MOVB R1, (R0)
;
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL TRIMTZ - Trim trailing zeros from a string
;
;  Modifies the passed string to remove any zeros from the end of
;  the string.  Similar to TRIMTS
;
str = 8.
trimtz::
	MOV R0, -(SP)	; Use as addresses
	MOV R1, -(SP)	; Lenght of string
	MOV R2, -(SP)	; Character to test
;
	MOV str(SP), R0
	INC R0
	MOVB (R0), R1
	BIC #byteh, R1
	INC R0
	ADD R1, R0	; Point to end of string
;
1$:	MOVB -(R0), R2
	CMPB #'0, R2
	BNE 2$		; Not a zero
	SOB R1, 1$
;
2$:	MOV str(SP), R0
	INC R0
	MOVB R1, (R0)
;
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL TRIMLS - Trim leading whitespace from a string
;
;  Modifies the passed string to remove any whitespace at the beginning
;  of the string.  Similar to TRIMTS
;
str = 10.
trimls::
	MOV R0, -(SP)	; Destination address
	MOV R1, -(SP)	; Length
	MOV R2, -(SP)	; Source address
	MOV R3, -(SP)	; Character to test
;
	MOV str(SP), R0
	INC R0
	MOVB (R0), R1	; Get string length
	BIC #byteh, R1
	MOV R0, R2	; R2 points to start of string
	INC R2
;
;  Now find the first non-whitespace character
;
1$:	MOVB (R2)+, R3
	CMPB #33., R3
	BHI 2$		; ASCII 32 or less
	CMPB #127., R3
	BHI 3$		; ASCII 126 or less
2$:	SOB R1, 1$
;
3$:	DEC R2		; Adjust source
	MOVB R1, (R0)	; Update string length
	INC R0
;
4$:	MOVB (R2)+, (R0)+	; Move the string up
	SOB R1, 4$

	MOV (SP)+, R3
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC


	.SBTTL TRIMLZ - Trim leading zeros from a string
;
;  Modifies the passed string to remove any zeros at the beginning
;  of the string.  Similar to TRIMTS
;
str = 10.
trimlz::
	MOV R0, -(SP)	; Destination address
	MOV R1, -(SP)	; Length
	MOV R2, -(SP)	; Source address
	MOV R3, -(SP)	; Character to test
;
	MOV str(SP), R0
	INC R0
	MOVB (R0), R1	; Get string length
	BIC #byteh, R1
	MOV R0, R2	; R2 points to start of string
	INC R2
;
;  Now find the first zero character
;
1$:	MOVB (R2)+, R3
	CMPB #'0, R3
	BNE 2$		; Not a zero
	SOB R1, 1$
;
2$:	DEC R2		; Adjust source
	MOVB R1, (R0)	; Update string length
	INC R0
;
4$:	MOVB (R2)+, (R0)+	; Move the string up
	SOB R1, 4$

	MOV (SP)+, R3
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC
;
	.SBTTL SUBSTR - Generalized substring routine
;
;  This routine extracts a substring from one string and copies
;  it to another string.  It is called with four parameters,
;  The source and destination string, the starting character, and
;  the number of characters to copy.  Of the starting character is
;  beyond the end of the source string, no characters will be
;  copied.  If the last character (start plus count) is beyond the
;  end of the source, copying will only happen to the end.  If the
;  destination string is smaller than the amount to be copied, it
;  will be truncated to the size of the destination.  Note that as
;  a special case, a count of 0 means to copy from the starting
;  character to the end of the source string.
;  The calling sequence is:
;  MOV source, -(SP)
;  MOV dest, -(SP)
;  MOV start, -(SP)
;  MOV count, -(SP)
;  JSR PC, substr
;  ADD #8., SP
substr::
count = 12.
start = 14.
dest = 16.
src = 18.
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV R2, -(SP)
	MOV R3, -(SP)
	MOV R4, -(SP)
;
;  Load parameters
;
	MOV src(SP), R0		; Address of source string
;	MOV dest(SP), R1	; Address of destination string
	MOV start(SP), R2	; Starting character
	MOV count(SP), R3	; Number of characters
;
;  Process inputs to figure out how much to really copy
;
	CMPB #0, R3		; Check if count is zero
	BNE 4$
	MOVB 1(R0), R3		; If so set count to length
4$:	CMPB R2, 1(R0)		; Is start after length
	BHI 99$			; If so, bail out
	MOV R2, R4
	ADD R3, R4		; Last character
	MOVB 1(R0), R1		; Length of source
	CMPB R4, R1		; Is end after length
	BLOS 1$			; If not, don't adjust
	SUB R1, R4		; Characters beyond end
	SUB R4, R3		; Adjusted length
	
1$:	MOV dest(SP), R1	; Get destination string
	CMPB R3, (R1)		; Is length greater than dest size
	BLOS 2$			; If not, don't adjust
	MOVB (R1), R3		; Set to dest size
2$:	MOVB R3, 1(R1)		; Set dest length
;
;  Copy the data
;
	ADD #2, R0
	ADD R2, R0		; Point to source start
	ADD #2, R1		; Point to dest start
	BIC #byteh, R3		; Clear any high bits in count
3$:	MOVB (R0)+, (R1)+	; Copy
	SOB R3, 3$
	JMP 100$
;
;  Set destination to be a 0 length string
;
99$:	MOV dest(SP), R1	; Get destination string
	MOVB #0, 1(R1)		; Set length to 0
;
;  Restore registers
;
100$:	MOV (SP)+, R4
	MOV (SP)+, R3
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC
;
	.END
