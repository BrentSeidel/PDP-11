;
;  This file contains some routines that work on strings.
;
	.TITLE STRING - Collection of routines to work on strings
	.IDENT "X0.00"
;
;  The data structure for a string is defined as follows:
;  str:  byte max - Maximum length of the string.  This should never change
;        byte len - Current length of the string.  Should be <= max
;        bytes buff - Buffer of max bytes containing the string.
;
;  Note that in general, if the destination is not large enough to hold
;  a string transfer, the destination will hold a truncated value.
;
	.PSECT STR,SAV,CON,GBL

	.SBTTL STRLEN - Get the length of a string
;  Called with the address of the string on the stack and returns
;  the length of the string on the stack.
;  Called as:
;  MOV str, -(SP)
;  JSR PC, strlen
;  MOV (SP)+, len
strlen::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV 6(SP), R0	; Get the address of the string
	INC R0		; Point to the length
	MOVB (R0), R1	; Get the length
	BIC #byteh, R1	; Clear any sign bits
	MOV R1, 6(SP)	; Save length on stack
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL STRMAX - Get the maximum length of a string
;  Called with the address of the string on the stack and returns
;  the maximum length of the string on the stack.
;  Called as:
;  MOV str, -(SP)
;  JSR PC, strmax
;  MOV (SP)+, max
strmax::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV 6(SP), R0
	MOVB (R0), R1
	BIC #byteh, R1
	MOV R1, 6(SP)
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL TRIMTS - Trim trailing whitespace from a string
;  Called with the address of the string on the stack and
;  modifes the string to remove any white space at the end
;  of the string.  White space is considered to be any character
;  with a code less than 33 or greater than 126.
;  Called as:
;  MOV str, -(SP)
;  JSR PC, strtrm
;  ADD #2, SP
trimts::
	MOV R0, -(SP)	; Use as addresses
	MOV R1, -(SP)	; Length of string
	MOV R2, -(SP)	; Character to test
;
	MOV 8.(SP), R0
	INC R0
	MOVB (R0), R1
	BIC #byteh, R1
	INC R0
	ADD R1, R0	; Point to end of string
;
1$:	MOVB -(R0), R2
	CMPB #33., R2
	BHI 2$		; ASCII 32 or less
	CMPB #127., R2
	BHI 3$		; Printable character found
2$:	SOB R1, 1$	; Loop and try again
;
3$:	MOV 8.(SP), R0
	INC R0
	MOVB R1, (R0)
;
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC

	.SBTTL TRIMLS - Trim leading whitespace from a string
;
;  Modifies the passed string to remove any whitespace at the beginning
;  of the string.  Similar to TRIMTS
;
str = 10.
trimls::
	MOV R0, -(SP)	; Destination address
	MOV R1, -(SP)	; Length
	MOV R2, -(SP)	; Source address
	MOV R3, -(SP)	; Character to test
;
	MOV str(SP), R0
	INC R0
	MOVB (R0), R1	; Get string length
	BIC #byteh, R1
	MOV R0, R2	; R2 points to start of string
	INC R2
;
;  Now find the first non-whitespace character
;
1$:	MOVB (R2)+, R3
	CMPB #33., R3
	BHI 2$		; ASCII 32 or less
	CMPB #127., R3
	BHI 3$		; ASCII 126 or less
2$:	SOB R1, 1$
;
3$:	DEC R2		; Adjust source
	MOVB R1, (R0)	; Update string length
	INC R0
;
4$:	MOVB (R2)+, (R0)+	; Move the string up
	SOB R1, 4$

	MOV (SP)+, R3
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC
;
;  The following three functions convert an unsigned 16 bit integer to a
;  string in octal, decimal, or hexidecimal representation.  They are all
;  called in a similar fashion:
;  MOV str, -(SP)
;  MOV num, -(SP)
;  JSR PC, xxxstr
;  ADD #4, SP
;
;  Note that if the destination string is not long enough to contain the
;  full converted number, it will be truncated.
;
	.SBTTL OCTSTR - Convert a number to an octal string
;
;  Converts an integer value to a string containing the octal representation
;
num = 10.	; Stack offset for number
str = 12.	; Stack offset for string pointer
octstr::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV R2, -(SP)
	MOV R3, -(SP)
;
;  Prepare to convert number
;
	MOV num(SP), R0		; Get the number passed
	MOV #numbuf, R2		; Address of destination buffer
	ADD #16., R2		; Point to end of buffer
	MOV #6, R3		; Loop count limit
;
;  Convert number to local buffer
;
1$:	MOV R0, R1
	BIC #177770, R1		; Least three bits
	MOVB numtbl(R1), -(R2)	; Copy ASCII digit to buffer
	ASH #-3, R0		; Shift out least octal digit
	BIC #160000, R0		; And clear any sign bits
	SOB R3, 1$		; Otherwise loop again
;
; Move to string (at this point, R2 points to the converted number)
;
	MOV str(SP), R0		; Get address of string
	MOVB (R0), R1		; Get string max size
	BIC #byteh, R1		; Clear any sign bits
	CMPB #6, R1		; Don't transfer more than max
	BHI 2$
	MOV #6, R1		; R1 is number of chars

2$:	INC R0			; Point to string length
	MOVB R1, (R0)
	INC R0			; Point to string buffer

3$:	MOVB (R2)+, (R0)+
	SOB R1, 3$
	JMP clnup
;
;  Converts an integer value to a string containing the decimal represenation
;
decstr::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV R2, -(SP)
	MOV R3, -(SP)
;
;  Prepare to convert number
;
	MOV num(SP), R0		; Get number passed
	MOV #numbuf, R2		; Address of destination buffer
	ADD #16., R2		; Point to end of destination
	MOV #5, R3		; Loop count
;
;  Convert number to local buffer
;
1$:	MOV R0, R1		; For DIV, R0/R1 is treated as a
	XOR R0, R0		; 32 bit number so this get it in place
	DIV #10., R0
	MOVB numtbl(R1), -(R2)	; Add digit to buffer
	SOB R3, 1$
;
;  Now R2 points to the converted number.  Mov to the destination
;  string
;
	MOV str(SP), R0		; Get address of string
	MOVB (R0), R1		; Get string max size
	BIC #byteh, R1		; Clear any sign bits
	CMPB #5, R1		; Make sure not to transfer any more
	BHI 2$			; than the max size
	MOV #5, R1

2$:	INC R0			; Point to string length
	MOVB R1, (R0)		; Set string length
	INC R0			; Point to string buffer

3$:	MOVB (R2)+, (R0)+	; Copy the data
	SOB R1, 3$
	JMP clnup
;
;  Convert an integer value to a string containing the hexidecimal
;  representation.
;
hexstr::
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV R2, -(SP)
	MOV R3, -(SP)
;
;  Prepare to convert number
;
	MOV num(sp), R0		; Get number passed
	MOV #numbuf, R2		; Address of destination
	ADD #16., R2		; Point to end of destination
	MOV #4, R3		; Loop count
;
;  Convert number to local buffer
;
1$:	MOV R0, R1
	BIC #byteh, R1		; Least 4 bits
	MOVB numtbl(R1), -(R2)	; Copy ASCII digit to buffer
	ASH #-4, R0		; Shift out least octal digit
	BIC #170000, R0		; and clear sign bits
	SOB R3, 1$		; Loop until done
;
;  Copy the string
;
	MOV str(SP), R0		; Address of string
	MOVB (R0), R1		; Max size of string
	BIC #byteh, R1		; Clear any sign bits
	CMPB #4, R1		; Make sure not to transfer
	BHI 2$			; than the max size
	MOV #4, R1

2$:	INC R0			; Point to string lenght
	MOVB R1, (R0)		; Set string length
	INC R0			; Point to string buffer

3$:	MOVB (R2)+, (R0)+	; Copy data
	SOB R1, 3$
	JMP clnup
;
;  Common cleanup to restore registers and return from numeric
;  conversion routines.
;
clnup:	MOV (SP)+, R3
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC
;
	.SBTTL SUBSTR - Generalized substring routine
;
;  This routine extracts a substring from one string and copies
;  it to another string.  It is called with four parameters,
;  The source and destination string, the starting character, and
;  the number of characters to copy.  Of the starting character is
;  beyond the end of the source string, no characters will be
;  copied.  If the last character (start plus count) is beyond the
;  end of the source, copying will only happen to the end.  If the
;  destination string is smaller than the amount to be copied, it
;  will be truncated to the size of the destination.  Note that as
;  a special case, a count of 0 means to copy from the starting
;  character to the end of the source string.
;  The calling sequence is:
;  MOV source, -(SP)
;  MOV dest, -(SP)
;  MOV start, -(SP)
;  MOV count, -(SP)
;  JSR PC, substr
;  ADD #8., SP
substr::
count = 12.
start = 14.
dest = 16.
src = 18.
	MOV R0, -(SP)
	MOV R1, -(SP)
	MOV R2, -(SP)
	MOV R3, -(SP)
	MOV R4, -(SP)
;
;  Load parameters
;
	MOV src(SP), R0		; Address of source string
;	MOV dest(SP), R1	; Address of destination string
	MOV start(SP), R2	; Starting character
	MOV count(SP), R3	; Number of characters
;
;  Process inputs to figure out how much to really copy
;
	CMPB #0, R3		; Check if count is zero
	BNE 4$
	MOVB 1(R0), R3		; If so set count to length
4$:	CMPB R2, 1(R0)		; Is start after length
	BHI 99$			; If so, bail out
	MOV R2, R4
	ADD R3, R4		; Last character
	MOVB 1(R0), R1		; Length of source
	CMPB R4, R1		; Is end after length
	BLOS 1$			; If not, don't adjust
	SUB R1, R4		; Characters beyond end
	SUB R4, R3		; Adjusted length
	
1$:	MOV dest(SP), R1	; Get destination string
	CMPB R3, (R1)		; Is length greater than dest size
	BLOS 2$			; If not, don't adjust
	MOVB (R1), R3		; Set to dest size
2$:	MOVB R3, 1(R1)		; Set dest length
;
;  Copy the data
;
	ADD #2, R0
	ADD R2, R0		; Point to source start
	ADD #2, R1		; Point to dest start
	BIC #byteh, R3		; Clear any high bits in count
3$:	MOVB (R0)+, (R1)+	; Copy
	SOB R3, 3$
	JMP 100$
;
;  Set destination to be a 0 length string
;
99$:	MOV dest(SP), R1	; Get destination string
	MOVB #0, 1(R1)		; Set length to 0
;
;  Restore registers
;
100$:	MOV (SP)+, R4
	MOV (SP)+, R3
	MOV (SP)+, R2
	MOV (SP)+, R1
	MOV (SP)+, R0
	RTS PC
;
	.END
                                                                                                                                                                                                                                                                                                                                                                                                    